#include "Vaes_main.h"         // Generated by Verilator
#include "verilated.h"
#include <iostream>
#include <bitset>

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);
    VlWide<4> result;
    Vaes_main *aes = new Vaes_main;

    // Set inputs (128-bit values split into 4 32-bit chunks)
    // Example: plaintext = 0x00112233445566778899aabbccddeeff
    //          key       = 0x000102030405060708090a0b0c0d0e0f

    // 128-bit input split into 4 x 32-bit words
    vluint32_t data_in[4] = {
        0xccddeeff, 0x8899aabb, 0x44556677, 0x00112233
    };
    vluint32_t key[4] = {
        0x0c0d0e0f, 0x08090a0b, 0x04050607, 0x00010203
    };

    // Corrected call with 128 bits specified
    VL_ASSIGN_W(128, aes->data_in, data_in);
    VL_ASSIGN_W(128, aes->key, key);

    // Evaluate (single-cycle, no clock needed unless your module uses one)
    aes->eval();

    // Output
    // std::cout << "Encrypted Output = 0x" << std::hex << aes->data_out << std::endl;

    for (int i = 0; i < 4; i++) {
        result[i] = aes->data_out[i];
    }

    // If you want to print or reconstruct:
    printf("Encrypted output:\n");
    for (int i = 3; i >= 0; i--) {
        printf("%08x", result[i]);
    }
    printf("\n");

    delete aes;
    return 0;
}
